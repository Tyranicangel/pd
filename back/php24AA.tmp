1) Use PDO classes or parameterized SQL queries to interact with database.

2) Implement access control on all the internal pages of the application. The application is not restricting to access the pages from un-authorized users (A valid low level user can able to access the pages of a high level user).

3) Include random tokens in each post request to protect from cross site request forgery attacks.

To include unique tokens in HTTP requests:
===========================================================================
-> Identify sensitive operations. Review application design and code to identify all operations that require authorization.

-> Identify code that performs sensitive operations. Identify all pages that are involved in performing sensitive operations - this includes both the pages that link    to sensitive operations and the code that actually carries out the sensitive operations.

-> Choose a method for generating unique tokens. There are different ways to generate unique tokens. One approach is to use the uniqid function combined with a hash    based on current time. 

	For example:
		uniqid(md5(microtime()), true);

-> Add the unique token to the session. Add code that adds the generates unique tokens and stores them in session variables to the pages that link to sensitive    operations. 

	For example:
		session_start();
		$_SESSION['CSRFToken'] = uniqid(md5(microtime()), true);

-> Add unique tokens to HTTP requests. Add code that sends the generated unique tokens in HTTP requests to the pages that link to sensitive operations. One of the simplest ways to do this is to include the tokens in hidden fields in forms. 

	For example:
		<input type="hidden" name="CSRFToken" value="<?php echo $_SESSION['CSRFToken'] ?>" />

-> Add token validation code. Add code to the pages that carry out sensitive operations that compares the tokens sent in HTTP requests to the tokens stored in session variables. Comparing the tokens in HTTP requests to tokens in session variables makes sure that the tokens are generated by the server as a part of normal application workflow and therefore the requested action is being performed by a legitimate user. 

	The validation code should look something like the following:
	session_start();
	
	if ($_POST['CSRFToken'] !== $_SESSION['CSRFToken']) {
	  // The tokens don't match - possible CSRF detected
	  die('Possible CSRF');
	}
	// Validation passed, so tokens match - perform the sensitive operation

========================================================================================

4) Implement input validation at server side.

To validate all user input using white-list input validation:
==========================================================================

-> Identify all entry points for user input. Make a list of all possible sources of user input in your application, such as form fields, POST/GET parameters, cookies, etc.

-> Identify all types on input accepted by the application. For each source of user input on the list, define valid characters, length, format, and range (for numerical values).

-> Define an input validation subsystem. Define a set of validator functions that should be used to validate each type of input handled by the application. Input should be validated on the server.

-> Validate characters. Restrict the acceptable range of characters in text input by using regular expressions.

-> Validate length. Add code to check that the length of the user input is valid.

-> Validate format. If the input type has a specific pattern, such as a date or a phone number, add code to use regular expressions to make sure user input matches the input type specified by the application. Use regular expressions to enforce strong password requirements.

-> Validate range. Restrict the acceptable range of numerical input by comparing the input to the maximum and minimum acceptable values.

-> (Optional) Reject and respond to known bad input. This step does not add much actual security, but it is included here to let you know that such an option exists. The input validation subsystem may check for known attack strings and respond to these likely attacks by doing things like logging detailed user information, alerting the administrator, blocking the user's IP address for some time, and displaying an error message to the attacker informing that you are onto him and reminding him of the consequences.

-> (Optional) Encode input. If the input is going to be displayed back through the web application, consider adding code to encode it to prevent Cross-Site Scripting attacks.

=================================================================================

5) Implement CAPTCHA on all the public forms (Login page and bill status pages).

6) The default password md5 is easily breakable. Force the user to choose high secure passwords by implementing password policy at server side. (Password length should be minimum 8 characters including atleast one numeric character, one special character and one Capital letter)

7) Deploy the application with trusted ssl certificate to elemenate eavesdrop attacks.


  

